[{"content":"基于xml的Spring Bean配置 实现FactoryBean的规范延迟实例化Bean 之前都是使用自定义的工厂方法来实现静态工厂，其实SPring提供了一个工厂Bean的规范接口，只要实现这个接口就可以实现静态工厂，不够此接口只有在调用getBean方法时才会实例化Bean并放入缓存池中。\n创建一个类并实现FactoryBean接口中的两个方法getObject与getObjectType\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class MyBeanFactory2 implements FactoryBean\u0026lt;UserDao\u0026gt; { @Override public UserDao getObject() throws Exception { System.out.println(\u0026#34;getObject被调用。。。\u0026#34;); return new UserDaoImpl(); } @Override public Class\u0026lt;?\u0026gt; getObjectType() { return UserDao.class; } } 在xml中正常配置bean标签,此时不在配置userDao对象的bean，而是配置对应的工厂对象bean：\n1 \u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;org.itHeima.factory.MyBeanFactory2\u0026#34; /\u0026gt; 运行后将产生如下结果：\n进入调试模式我们可以发现在读取xml配置文件时，并没有实例化userDao对象，而是将工厂对象进行实例化并放入单例池中：\n注意此时userDao对应的value为MyBeanFactory2。在调用getBean方法后，userDao对象将被实例化并放入缓存池中，下一次调用时将直接获取：\n注入方式和注入数据类型 常见注入方式包括构造器注入和setter方法注入，对应的标签也别分为两种\nconstructor-arg 适用于构造方法注入或静态工厂方法注入\nproperty 适用于setter方法注入，name属性值为set后面内容(首字母小写)\n1 2 //如setAge，xml中应写 \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34; /\u0026gt; 数据类型与对应属性 普通数据类型 如String、int、bool等数据类型，使用value属性即可\n1 2 \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;xm\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; 引用数据类型 具体实例化对象等，使用ref属性(对应在配置文件中声明的bean的id属性)\n1 \u0026lt;constructor-arg name=\u0026#34;userService\u0026#34; ref=\u0026#34;userService\u0026#34; /\u0026gt; 注入集合数据类型 对应集合类型，使用对应的标签\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //list \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;dddd\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;aaaa\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;xxxx\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; //set \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;ddd\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;xxx\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;yyy\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; //map \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;d1\u0026#34; value=\u0026#34;userService\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;d2\u0026#34; value=\u0026#34;userService\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;d3\u0026#34; value=\u0026#34;userService\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; //.... 自动装配 在SpringBoot中常常使用自动注入@AutoWire注解，这个在xml配置中也是存在的。有两种常用属性，通过名字(id)注入或通过类型注入，在通过类型注入中，如果有超过两种以上相同类型的bean实例化，就会报错。\n1 2 3 \u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;org.itHeima.Dao.impl.UserDaoImpl\u0026#34; autowire=\u0026#34;byName\u0026#34; /\u0026gt; //or \u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;org.itHeima.Dao.impl.UserDaoImpl\u0026#34; autowire=\u0026#34;byType\u0026#34; /\u0026gt; 命名空间的种类 在xml中可以指定多个命名空间,使用xmlns属性指定，其中:后内容为命名空间别名\n1 2 3 4 5 6 7 8 \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; \u0026lt;!-- 指定context为别名 --\u0026gt; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context \u0026lt;!-- 设置路径 --\u0026gt; http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;/beans\u0026gt; 也可设置第三方的命名空间，只有有路径和地址即可。\n默认命名空间的默认标签 beans标签 最核心的标签，可以通过profile属性指定运行环境，在系统运行时可指定运行环境，即可选择对应环境内的bean\n1 2 3 \u0026lt;beans profile=\u0026#34;test\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userDao1\u0026#34; class=\u0026#34;org.itHeima.dao.impl.userDaoImpl\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 可在运行时指定环境\n1 System.setProperty(\u0026#34;spring.profiles.active\u0026#34;, \u0026#34;test\u0026#34;); 其会加载默认空间的bean和test空间的bean。\nimport标签 导入外部xml配置文件\n1 \u0026lt;import resource=\u0026#34;classpath:xxx.xml\u0026#34; /\u0026gt; alias标签 起别名\n1 \u0026lt;alias name=\u0026#34;userDao\u0026#34; alias=\u0026#34;aaa,bbb,ccc\u0026#34;/\u0026gt; ","date":"2023-03-20T17:19:05+08:00","image":"https://cdn.jsdelivr.net/gh/mnmnmssd/hexoBlogimg@master/2023/03/upgit_20230320_1679308851_6.jpg","permalink":"https://www.bigcry.asia/p/springday03/","title":"SpringDay03"},{"content":"基于XML的Bean配置 基础属性 BeanName与别名 bean标签除了id属性指定唯一标识外，还允许使用name属性指定多个别名\n1 \u0026lt;bean id=\u0026#34;userDao\u0026#34; name=\u0026#34;aaa,bbb,ccc\u0026#34; class=\u0026#34;org.itHeima.Dao.impl.userDaoImpl\u0026#34; /\u0026gt; 此时，除了使用userDao可以获取Bean之外，还可以使用aaa、bbb、ccc来获取，此时这些别名都将保存在单例池中的别名集合中\n1 UserDao userDao = (UserDao) applicationContext.getBean(\u0026#34;aaa\u0026#34;); 假如在声明时并未指定id、name属性，那么此时通过类路径也就是class属性中的内容来获取，除此以外，也可以直接通过类型匹配来获取\n1 2 3 4 //通过类路径 UserDao userDao = (UserDao) applicationContext.getBean(\u0026#34;org.itHeima.Dao.impl.userDaoImpl\u0026#34;); //通过类型匹配 UserDao userDao = applicationContext.getBean(UserDao.class); Bean的作用范围 初始引入spring-context包时，Bean的作用范围只有两个，分别为singleton(单例)与prototype(原型)\nsingleton(单例) 顾名思义，在整个Bean的生命周期内，只会产生一个实例化对象，每次使用getBean都获取的是同一个对象，这也是spring默认的Bean作用域。\n1 2 UserService userService = (UserService) applicationContext.getBean(\u0026#34;userService\u0026#34;); UserService userService2 = (UserService) applicationContext.getBean(\u0026#34;userService\u0026#34;); prototype(原型) 其表示一个Bean对应多个实例对象，并且在读取配置文件时并不会创建Bean对象，而是在每次使用getBean方法获取Bean实例时才会创建，并且每次getBean都会创建并返回一个新的Bean对象。\nBean的延迟加载 如果使用的是BeanFactory方式创建bean对象时，Bean是在使用getBean方法时实例化，而在使用ApplicationContext方式创建时，Bean是在读取配置文件时实例化，通过lazy-init属性则可以控制这一过程。其取值有default、false与true三种。\n延迟加载只能修改ApplicationContext方式，对BeanFactory方式不起效。\n1 \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;org.itHeima.service.impl.UserServiceImpl\u0026#34; lazy-init=\u0026#34;true\u0026#34; /\u0026gt; 运行后，调试发现在读取配置文件时并没有实例化对象和存入单例池。\n只有当调用getBean方法时，才会实例化并放入单例池。\n初始化方法和销毁方法 Spring支持在Bean实例化时执行一些初始方法，并在其销毁前执行销毁方法，使用init-method与destroy-method属性来指定执行的方法名称。\n在UserServiceImpl类中我们添加两个方法。\n1 2 3 public UserServiceImpl() {System.out.println(\u0026#34;无参构造执行...\u0026#34;);} public void init() {System.out.println(\u0026#34;init方法执行...\u0026#34;);} public void destroy() {System.out.println(\u0026#34;destroy方法执行...\u0026#34;);} 在xml配置文件中，我们使用init-method与destroy-method属性来指定方法。\n1 \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;org.itHeima.service.impl.UserServiceImpl\u0026#34; init-method=\u0026#34;init\u0026#34; destroy-method=\u0026#34;destroy\u0026#34;\u0026gt; 执行后可以看到以下输出：\n在结果中我们可以得知init方法是在构造方法之后才会执行，并且并没有输出销毁方法。这是为什么呢，这是因为程序并没有显式的关闭，而是自动停止运行，就好像突然停电，电脑内的一部分数据都没来得及进行保存。所以我们要显式的关闭才会执行销毁方法。\n修改main方法中的代码，由于ApplicationContext并没有声明显式关闭方法，所以我们直接使用它的接口实现类ClassPathXmlApplicationContext中的close方法。\n1 2 ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); applicationContext.close(); 运行后就可以看到以下输出\ninitializingBean方法初始化 除了使用init-method属性指定初始化方法外，Spring还允许对象通过实现InitializingBean接口中的afterPropertiesSet方法来进行初始化。\n1 2 3 4 5 6 7 8 public class UserServiceImpl implements UserService, InitializingBean{ //...其他方法 @Override public void afterPropertiesSet() throws Exception { System.out.println(\u0026#34;afterPropertiesSet方法执行....\u0026#34;); } } 执行后可以有以下输出：\n这里我们也可以看到，afterPropertiesSet方法的执行是在init-method属性指定的初始化方法前执行的。\n实例化Bean的方法 静态工厂方法 类似于单例工厂模式\n新建一个MyBeanFactory类，此类有一个静态方法getBean来获取一个UserServiceImpl实例化对象\n1 2 3 4 5 public class MyBeanFactory { public static UserService getBean() { return new UserServiceImpl(); } } 在xml文件中进行配置\n1 \u0026lt;bean id=\u0026#34;userServiceFactory\u0026#34; class=\u0026#34;org.itHeima.factory.MyBeanFactory\u0026#34; factory-method=\u0026#34;getBean\u0026#34; /\u0026gt; 此配置并不会将MyBeanFactory加入单例池，而是会自动执行工厂内的getBean方法来返回UserServiceImpl实例化对象\n实例工厂方法 修改上述MyBeanFactory类，将静态方法修改为普通方法。\n同时修改xml配置为\n1 2 \u0026lt;bean id=\u0026#34;userServiceFactory\u0026#34; class=\u0026#34;org.itHeima.factory.MyBeanFactory\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; factory-bean=\u0026#34;userServiceFactory\u0026#34; factory-method=\u0026#34;getBean\u0026#34;/\u0026gt; 再次运行会产生和上述一样的结果,区别在于将我们的MyBeanFactory类也加入了单例池中\n带参静态工厂与实例工厂方法 如果我们的实例化对象在构造时存在参数的传入(带参构造，Bean实例化必须存在一个无参构造)，此时我们可以使用constructor-arg标签来指定参数名称(name属性)与数值(value属性)。\n修改上述自定义工厂的getBean方法为带参方法\n1 2 3 4 public UserService getBean(String name, int age) { System.out.println(\u0026#34;name:\u0026#34; + name + \u0026#34;\\n\u0026#34; + \u0026#34;age:\u0026#34; + age); return new UserServiceImpl(); } 修改xml文件，在获取对应实例对象的bean标签下添加\n1 2 3 4 \u0026lt;bean id=\u0026#34;userService\u0026#34; factory-bean=\u0026#34;userServiceFactory\u0026#34; factory-method=\u0026#34;getBean\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;test\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 运行后即可正常输出\n小结 Spring博大精深啊\n","date":"2023-03-17T16:55:36+08:00","permalink":"https://www.bigcry.asia/p/spring%E5%AD%A6%E4%B9%A0-02/","title":"SpringDay02"},{"content":"Spring概述 Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好、易于测试、可重用的代码。\nSpring 框架是一个开源的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首次在 Apache 2.0 许可下发布。\nSpring 是轻量级的框架，其基础版本只有 2 MB 左右的大小。\nSpring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 的编程模型来促进良好的编程实践。\nSpring快速入门 本项目使用Maven构建\nSpring IOC容器 在常规Java开发中，Bean的管理常常是非常头疼的事情，常规一般随用随new，造成极大资源浪费，而且增大了代码的耦合程度，使定位问题和修改成为了极大的困难，Spring的出现解决了这一问题，他将开发者与Bean进行了抽离，在两者之间使用Bean工厂进行链接，使Bean的创建与管理极大的便利了起来。\n常规方式管理Bean：开发者\u0026ndash;\u0026gt;Bean\nSpring方式管理Bean：开发者\u0026ndash;\u0026gt;第三方工具\u0026ndash;\u0026gt;Bean\nSpring中提供了两种方式创建Bean对象，一种使用BeanFactory来创建，一种使用ApplicationContext来创建。\n以上两种方式需要首先从配置文件中指定bean的名称等属性\n创建xml配置文件 首先ApplicationContext有三种方式\n系统路径获取配置文件 (FileSystemXmlApplicationContext) 直接获取配置文件 (ClassPathXmlApplicationContext) 注解方式获取Bean (AnnotationConfigApplicationContext) 我们这里使用第二种也是除了注解外最常用的一种方式，在项目的resource文件夹下创建applicationContext.xml文件。\n文件初始内容如下\n1 2 3 4 5 6 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;/beans\u0026gt; 我们在项目中创建几个测试Bean对象，如下图所示，其中UserServiceImpl实现了UserService接口，并在内部引用了UserDao对象。\nUserServiceImpl内部书写\n1 2 3 4 5 6 private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; System.out.println(userDao); } 使用BeanFactory创建Bean对象 首先我们使用BeanFactory方式创建Bean对象。\nBean标签形式 编辑我们创建的applicationContext.xml文件，配置如下\n1 \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;org.itHeima.service.impl.UserServiceImpl\u0026#34; /\u0026gt; 其中bean标签表示为一个bean对象，id属性为唯一标识，在后续中可通过该标识获取Bean对象，class属性为实例化对象位置。\n接下来我们在主包下创建BeanFactoryTest测试类来测试，其中main方法内书写如下\n1 2 3 4 5 6 7 8 9 10 //创建Bean工厂 DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); //创建读取器 XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory); //读取配置文件 reader.loadBeanDefinitions(\u0026#34;applicationContext.xml\u0026#34;); //通过getBean获取Bean对象 UserService userService = (UserService) beanFactory.getBean(\u0026#34;userService\u0026#34;); System.out.println(userService); 在这种方法下userService中并没有实例化userDao对象，运行后可以观测到输出\norg.itHeima.service.impl.UserServiceImpl@28f67ac7。\n自动注入形式 修改xml配置文件中内容为\n1 2 3 4 \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;org.itHeima.service.impl.UserServiceImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;userDao\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;org.itHeima.Dao.impl.UserDaoImpl\u0026#34;/\u0026gt; 其中property标签表示其为当前bean的一个属性内容，这里的name属性应该与userServiceImpl中的setUserDao方法中set后的名称(UserDao-\u0026gt;userDao)吻合,并不是下方的id属性，后面的ref属性才应为要自动注入的bean的id属性。\nmain方法不变。\n运行后应输出以下内容\n1 2 org.itHeima.Dao.impl.UserDaoImpl@17550481 //userDao对象实例地址 org.itHeima.service.impl.UserServiceImpl@735f7ae5 //userService对象实例地址 以上为BeanFactory方法创建Bean对象，可以见到代码略多，不易记忆，而且功能较少，接下来我们将使用也是开发中常用的ApplicationContext方法来创建实例Bean。\n使用ApplicationContext创建Bean xml配置文件不用改变，我们创建一个ApplicationContextTest测试类来测试，在main方法中输入以下内容\n1 2 3 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserService userService = (UserService) applicationContext.getBean(\u0026#34;userService\u0026#34;); System.out.println(userService); 运行后将输出与上方BeanFactory方法运行相一致的结果。\nApplicationContext与BeanFactory的区别 那么为什么在工作中常常使用ApplicationContext来进行Bean的创建呢，一个是代码简单易于记忆，而另外就是它与BeanFactory有着截然的不同。\nApplicationContext脱身于BeanFactory，又青出于蓝而胜于蓝，比传统的BeanFactory多出了很多功能，包括监视器、国际化等。我们在它的类继承图中也可以看到，它实现了BeanFactory接口，又实现了其他一些功能性的接口，加强了自身的功能。 BeanFactory更应该称之为一个Spring工厂，负责生产和管理Bean，而ApplicationContext更高级一些，可以被称之为Spring容器。 Bean的初始化时机不同，在默认情况下，ApplicationContext在读取配置文件的同时就创建好了Bean并添加到了Bean池中，而BeanFactory是在首次getBean时才会对对象实例并初始化，这里可以进行调试验证，分别在ApplicationContextTest测试类中的读取配置文件与BeanFactoryTest测试类中读取配置文件处打上断点，进行调试。会发现在ApplicationContextTest执行完毕配置文件读取后，单例Bean池内已经存在了userService对象 ​\t​\t而调试BeanFactoryTest测试类时我们发现，再执行完毕加载配置文件后，单例池内并没有出现userService对象，而在执行getBean方法时，才正式加到了单例池内。如下图\n​\t​\t执行getBean方法后\n​\t小结 今天学习了Spring中常见的Bean生产方式，分为BeanFactory与ApplicationContext方式，后者更为常用与强大。\n虽然如今SpringBoot与SpringCould如火如荼，但其底层仍为Spring框架，之前只是使用SpringBoot进行项目开发，并未从源码角度进行思考，只是会用的级别，此次从新学习Spring有了更多感悟。\n","date":"2023-03-16T17:45:29+08:00","permalink":"https://www.bigcry.asia/p/spring%E5%AD%A6%E4%B9%A0/","title":"SpringDay01"},{"content":"0x00 事件起因 最近在搞毕设，其中有一个模块需要用到人脸识别服务，遂去网上寻找现成的轮子，终于在某慕课平台上发现了一款简单的人脸识别框架，其使用cython编写并编译成C代码，借助Flask框架实现Web服务。下载运行的过程此处不多细说。\n运行十分顺利，docker一键部署即可，结果在调用其生成的服务接口时出现问题，其应返回一串由python生成的人脸模型字符串，结果他给我返回了个icode不正确，经查询发现，其还需要向慕课后台传递一串随机code，此code只有购买该课程的人才能生成并有时效性，奈何本人囊中羞涩，实在付不起昂贵的课程费用，于是动起了小心思。\n0x01 返本溯源 既然我都有了该人脸识别程序，为何不从其源码入手呢，所以打开下载的源码包，结果发现是一个由cython编译生成的C文件与一个编译生成的SO二进制文件，打开c文件，由python编译后的c代码属实是晦涩难懂，不过经过层层分析，还是找到了相应的检查code代码，但是却无从下手，因为编译后的代码是这样的\n我透，这尼玛怎么改，直接放弃！\n0x02 偷天换日 虽然无法修改，但是依然发现了一个值得注意的点，就是提交的这个code会在服务内请求某慕课服务器做验证，根据返回值再次验证，最后在返回给我们，既然如此，我们拦截这个验证code的请求，然后修改它的响应包不就可以了，由于该服务运行在linux上，所以需要寻找一个适用于linux，并且能够自动监听指定URL，自动修改响应包的一个软件，毕竟我没有功夫每一次请求都自己手动修改。于是，mitmproxy出现了\n顾名思义，mitmproxy 就是用于 MITM 的 proxy，MITM 即中间人攻击（Man-in-the-middle attack）。用于中间人攻击的代理首先会向正常的代理一样转发请求，保障服务端与客户端的通信，其次，会适时的查、记录其截获的数据，或篡改数据，引发服务端或客户端特定的行为。\n不同于 fiddler 或 wireshark 等抓包工具，mitmproxy 不仅可以截获请求帮助开发者查看、分析，更可以通过自定义脚本进行二次开发。举例来说，利用 fiddler 可以过滤出浏览器对某个特定 url 的请求，并查看、分析其数据，但实现不了高度定制化的需求，类似于：“截获对浏览器对该 url 的请求，将返回内容置空，并将真实的返回内容存到某个数据库，出现异常时发出邮件通知”。而对于 mitmproxy，这样的需求可以通过载入自定义 python 脚本轻松实现。\n没错，它可以运行自己写的python脚本实现自动化抓包改包，直接上手使用，具体安装教程可以查看官方文档，需要注意的是如果拦截https请求需要安装认证证书，我在这里说一下ubuntu/Debian的安装方法\n在以下位置为额外的 CA 证书创建一个目录/usr/local/share/ca-certificates：\n1 sudo mkdir /usr/local/share/ca-certificates/extra 首先将mitmproxy自带的.pem文件转换为.crt文件：\n1 2 # pem文件在~/.mitmproxy文件夹内，后缀名为.pem openssl x509 -in foo.pem -inform PEM -out foo.crt 将 CA.crt文件复制到此目录：\n1 sudo cp foo.crt /usr/local/share/ca-certificates/extra/foo.crt 让 Ubuntu 添加相对于的文件.crt路径：/usr/local/share/ca-certificates``/etc/ca-certificates.conf\n1 2 3 sudo dpkg-reconfigure ca-certificates # 要以非交互方式执行此操作，请运行： sudo update-ca-certificates 这样下来，就安装好了证书，然后简单的写一个脚本文件（直接把官方示例脚本修改修改完事）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import mitmproxy.http from mitmproxy import ctx class Counter(): def __init__(self): self.num=0 def request(self, flow: mitmproxy.http.HTTPFlow): self.num+=1 def response(self, flow: mitmproxy.http.HTTPFlow): if \u0026#34;XXX.com\u0026#34; in flow.request.url: import json flow.response.set_text(json.dumps({\u0026#34;msg\u0026#34;:\u0026#34;success\u0026#34;,\u0026#34;data\u0026#34;:\u0026#34;success\u0026#34;,\u0026#34;code\u0026#34;:1000})) data = json.loads(str(flow.response.content, encoding=\u0026#39;utf-8\u0026#39;)) ctx.log.info(\u0026#34;data = {}\u0026#34;.format(data)) addons = [ Counter() ] 然后修改系统代理为127.0.0.1:8080，输入mitmdump -s test.py命令启动，使用curl命令简单测一下，非常ok\n可以看到日志输出，已经成功拦截并修改响应了，直接上实机运行！\n0x03 攻营拔寨 前端发起请求，后端处理请求，嗯？怎么返回了500，看一看日志输出\n我好不容易动心一次，你却让我输的如此彻底！焯！！\n明明已经配置好了CA证书，curl命令请求https的域名也通过了，为什么到这里却失败了呢，继续查看源代码，忽然想起这是由python编译而来的C代码，运行也是由python3运行，会不会是python内部出了问题，于是百度一下后，发现果然，因为有代理的存在，所以python的request库还需要一步CA认证，解决方法就是关掉代理，焯！这不是绕了一圈又回到原点了嘛。既然拦截和源码都靠不住，我就盯上了它的运行文件xx.so，他是由cython编译生成的so文件库，主要运行就是运行它，直接记事本打开，好嘛，直接乱码，百度了一下知道了他是二进制文件，那么就使用对二进制宝器\u0026mdash;IDA，直接反编译so文件，修改内部参数不就可以了。\n使用IDA打开so文件，找到其中的请求地址，然后修改它，将https请求修改为http请求，万幸他没有做跳转，http请求正常使用\n再次实机运行，一切完美\n0x04 END 其实最后都可以修改内部参数，完全可以将请求的路径修改为本地路径，本地在搭建个小服务器返回正确的响应就好，一些软件的破解也是这么做的，或者修改其中验证code函数的返回值都i是可以的。为了搞这个服务，把好多年扔下的反编译老底都掏出来了，还是希望有能力的人可以支持正版，支持他人的劳动成果吧！\n","date":"2022-03-04T17:12:47Z","permalink":"https://www.bigcry.asia/p/114514/","title":"记一次被迫反编译加中间人攻击"},{"content":"Spring boot (扩展)博客系统 主要扩展功能 在老师已有基础上扩展\n0x00评论管理 效果图（前端页面由文章管理页面更改部分参数而成） 分析效果图，至少需要实现以下两功能\n点击评论管理进入评论管理页面，并显示全部评论 可以对单一评论进行操作，并且点击评论可以跳转对应文章 分析效果图，分析得到的功能由Controller层承担的，由此开始向下分析\n显示全部评论 Mapper层 CommentMapper.java 1 2 //获取所有评论，按照新发布进行排序 List\u0026lt;Comment\u0026gt; selectComments() ; CommentMapper.xml 1 2 3 \u0026lt;select id=\u0026#34;selectComments\u0026#34; resultType=\u0026#34;com.example.blog_system.entity.Comment\u0026#34;\u0026gt; select * from t_comment order by id desc \u0026lt;/select\u0026gt; Service层 CommentServiceImpl 1 2 3 4 5 6 @Override public PageInfo\u0026lt;Comment\u0026gt; getAllComments( int page, int count) { PageHelper.startPage(page, count); List\u0026lt;Comment\u0026gt; comments = commentMapper.selectComments(); return new PageInfo\u0026lt;\u0026gt;(comments); } Controller层 AdminController 1 2 3 4 5 6 7 8 9 @GetMapping(\u0026#34;/comments\u0026#34;) public String commentsManage(@RequestParam(value = \u0026#34;page\u0026#34;, defaultValue = \u0026#34;1\u0026#34;) int page, @RequestParam(value = \u0026#34;count\u0026#34;, defaultValue = \u0026#34;10\u0026#34;) int count, HttpServletRequest request) { PageInfo\u0026lt;Comment\u0026gt; comments = commentService.getAllComments(page, count); request.setAttribute(\u0026#34;comments\u0026#34;, comments); return \u0026#34;back/comments_list\u0026#34;; } 对评论进行操作 Mapper层 CommentMapper.java 1 int deleteByAid(Integer aid); CommentMapper.xml 1 2 3 4 \u0026lt;delete id=\u0026#34;deleteByAid\u0026#34;\u0026gt; delete from t_comment where article_id = #{aid, jdbcType=INTEGER} \u0026lt;/delete\u0026gt; Service层 CommentServiceImpl 1 2 3 4 @Override public void deleteComment(Integer id) { commentMapper.deleteByPrimaryKey(id); } Controller层 AdminController 1 2 3 4 5 6 7 8 9 10 @PostMapping(\u0026#34;/comments/delete\u0026#34;) @ResponseBody public ResponseData deleteComment(@RequestParam int id) { try { commentService.deleteComment(id); return ResponseData.ok(); } catch (Exception e) { return ResponseData.fail(); } } 0x01标签/分类 效果图 分析该效果图，可知主要元素为中间展示的词云部分，该词云以分类权重为标识，权重越大，字符越大，在此处我们使用外部js库实现。\nJQcloud库 我们借助外部库来实现词云效果，这里简单介绍一下JQcloud库，他是一个基于Jquery的简单易用的词云生成库，通过阅读他的官方文档我们可以得知它接受对象数组类型的参数,主要参数有\n参数 含义 text 主要参数，这里用分类名 weight 权重，只用分类下的文章数 link 跳转链接 使用其内置方法添加词云\n1 $(\u0026#34;#example\u0026#34;).jQCloud(word_array); 根据以上数据，我们分析得到的信息\n后台需要传过来分类的类别名，权重，链接等 前端接收数据并通过JQcloud渲染词云 通过分析，我们新建一个Tag实体类，并以此延申其的Service层、Mapper层等\nTag类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package com.example.blog_system.entity; /** * @author 笑的心酸 - Red4Lion - mnmnmssd * @date 2021.10.19 */ public class Tag { private String text; private int weight; private String link; public String getLink() { return link; } public void setLink(String link) { this.link = link; } public String getText() { return text; } public void setText(String text) { this.text = text; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } } 显示所有分类 Mapper层 TagsMapper.java 1 2 //获取全部分类详细信息 List\u0026lt;Tag\u0026gt; selectCounts(); TagsMapper.xml 1 2 3 4 \u0026lt;select id=\u0026#34;selectCounts\u0026#34; resultType=\u0026#34;com.example.blog_system.entity.Tag\u0026#34;\u0026gt; SELECT categories as text, COUNT(categories) as weight FROM `t_article` GROUP BY categories \u0026lt;/select\u0026gt; Service层 tagsService 1 2 3 4 5 6 7 8 9 @Override public List\u0026lt;Tag\u0026gt; getTagsCount() { List\u0026lt;Tag\u0026gt; tags = tagsMapper.selectCounts(); tags.replaceAll(tag -\u0026gt; { tag.setLink(\u0026#34;tags/\u0026#34; + tag.getText()); return tag; }); return tags; } Controller层 Admincontroller 1 2 3 4 5 6 7 8 @GetMapping(\u0026#34;/tags\u0026#34;) public String toTags(HttpServletRequest request, Model model) { List\u0026lt;Tag\u0026gt; tagList = iTagsService.getTagsCount(); model.addAttribute(\u0026#34;tagList\u0026#34;, tagList); return \u0026#34;back/tags\u0026#34;; } 前端页面 从官方git主页下载JQcloud库并放入static/back/js(css)/下\n引入必备库\n1 2 3 \u0026lt;script th:src=\u0026#34;@{http://apps.bdimg.com/libs/jquery/1.9.1/jquery.min.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link th:href=\u0026#34;@{/back/css/jqcloud.css}\u0026#34; rel=\u0026#34;stylesheet\u0026#34;/\u0026gt; \u0026lt;script th:src=\u0026#34;@{/back/js/jqcloud-1.0.4.min.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 页面布局 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;div id=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;div th:replace=\u0026#34;back/header::header-body\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content-page\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;example\u0026#34; class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div th:replace=\u0026#34; back/footer :: footer-content\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div th:replace=\u0026#34;back/footer :: footer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; JQcloud渲染数据 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script th:inline=\u0026#34;javascript\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt; var tagList = [[${tagList}]]; console.log(tagList) var word_array = tagList $(function () { $(\u0026#34;#example\u0026#34;).jQCloud(word_array, { height: 850 //设置生成词云的高度 }); }); \u0026lt;/script\u0026gt; 单独显示某一分类下文章 用户点击某一分类后跳转到该分类下所有文章列表\n效果图 分析该效果图，可得知需向后台传递分类参数，后台返回分类下所有文章列表\nMapper层 TagsMapper.java 1 2 //获取某一分类下的文章 List\u0026lt;Article\u0026gt; selectArticleByTag(String categories); TagsMapper.xml 1 2 3 4 5 \u0026lt;select id=\u0026#34;selectArticleByTag\u0026#34; resultType=\u0026#34;com.example.blog_system.entity.Article\u0026#34; parameterType=\u0026#34;java.lang.String\u0026#34; \u0026gt; SELECT * FROM `t_article` where categories = #{categories,jdbcType=VARCHAR} \u0026lt;/select\u0026gt; Service层 TagService 1 2 3 4 5 6 7 8 @Override public PageInfo\u0026lt;Article\u0026gt; getArticleByTag(Integer page, Integer count, String categories) { List\u0026lt;Article\u0026gt; articles = tagsMapper.selectArticleByTag(categories); PageHelper.startPage(page, count); return new PageInfo\u0026lt;\u0026gt;(articles); } Controller层 AdminController 1 2 3 4 5 6 7 8 9 10 11 @GetMapping(\u0026#34;tags/{tag}\u0026#34;) public String showTagsArticles(@RequestParam(value = \u0026#34;page\u0026#34;, defaultValue = \u0026#34;1\u0026#34;) int page, @RequestParam(value = \u0026#34;count\u0026#34;, defaultValue = \u0026#34;10\u0026#34;) int count, @PathVariable(\u0026#34;tag\u0026#34;) String tag, HttpServletRequest request) { PageInfo\u0026lt;Article\u0026gt; pageInfo = iTagsService.getArticleByTag(page, count, tag); request.setAttribute(\u0026#34;tagTitle\u0026#34;, tag); request.setAttribute(\u0026#34;articles\u0026#34;, pageInfo); return \u0026#34;back/tag_article_list\u0026#34;; } 前端页面 由文章管理更改而来，不再赘述\n优化发布文章 由于之前发布文章时没有设置文章分类，导致所有文章分类都是默认分类，所以将其优化。\n效果图 通过分析上图可得，需要在前端页面添加一个可以输入并且可以选择分类的输入框，选择框可以动态的获取所有分类，输入框可以添加新分类。\n这种可以输入并且可以选择的input输入框初看很新颖，但是我们细细一想就可以得到方案，将输入框定位到选择框上，并且在选择框中内容发生改变时同步到输入框中。于是得到以下代码\n优化方案 article_edit.html 1 2 3 4 5 6 7 \u0026lt;th:block th:unless=\u0026#34;${null != contents}\u0026#34;\u0026gt; \u0026lt;select class=\u0026#34;form-control\u0026#34; id=\u0026#34;spec_num\u0026#34; name=\u0026#34;spec_num\u0026#34; onchange=\u0026#34;document.getElementById(\u0026#39;categories\u0026#39;).value=$(\u0026#39;#spec_num option:selected\u0026#39;).text()\u0026#34;\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;input name=\u0026#34;categories\u0026#34; id=\u0026#34;categories\u0026#34; type=\u0026#34;text\u0026#34; class=\u0026#34;form-control selectInput\u0026#34; placeholder=\u0026#34;请选择/新建文章分类\u0026#34;/\u0026gt; \u0026lt;/th:block\u0026gt; css部分 1 2 3 4 5 6 7 8 9 10 11 .selectInput { position: absolute; width: 85%; height: 34px; left: 0px; top: 0px; border-bottom: 0px; border-right: 0px; border-left: 0px; border-top: 0px; } js部分，获取后台数据 1 2 3 4 5 6 7 8 var catoegoriess = [[${catoegoriess}]]; //根据id查找对象， var obj = document.getElementById(\u0026#39;spec_num\u0026#39;); catoegoriess.forEach(function (tag) { //添加一个选项 obj.options.add(new Option(tag, tag)); //这个兼容IE与firefox }) 修改发布文章article.js的提交语句 1 2 3 var catoegories = $(\u0026#39;#articleForm input[name=categories]\u0026#39;).val() ... $(\u0026#34;#articleForm #categories\u0026#34;).val(catoegories); 后台优化分类数据 Mapper层 1 2 //获取全部分类 public List\u0026lt;String\u0026gt; getTags(); Service层 1 2 3 4 @Override public List\u0026lt;String\u0026gt; getTags() { return tagsMapper.getTags(); } Controller层 在文章发布api下添加\n1 2 List\u0026lt;String\u0026gt; tags = iTagsService.getTags(); request.setAttribute(\u0026#34;catoegoriess\u0026#34;, tags); 0x02系统设置 用户管理 效果图 遇到的错误及问题 在开发中遇到了405错误，后端接口一直返回Request method 'POST' not supported错误，而在controller中已经声明了前端请求方法为POST，在查询资料与debug中发现，原来起端使用的fetch在请求后端时并没有设置请求头hearder，于是在fetch设置中向请求头中加入\n1 2 3 headers: { \u0026#34;Content-Type\u0026#34;:\u0026#34;application/x-www-form-urlencoded\u0026#34; } 但是仍报405错误，分析请求头信息，发现没有设置用户token导致后台的安全机制认为有用户发起CSRF攻击，所以采取反制措施。于是再次添加请求头信息\n1 2 3 4 5 6 7 // 获取\u0026lt;meta\u0026gt;标签中封装的_csrf信息 var token = $(\u0026#34;meta[name=\u0026#39;_csrf\u0026#39;]\u0026#34;).attr(\u0026#34;content\u0026#34;); ... headers: { \u0026#34;Content-Type\u0026#34;:\u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;x-csrf-token\u0026#34;:token } 这里简单了解一下 跨站请求伪造Cross Site Request Forgery（CSRF），正是如同他的名字一样，当黑客获取用户cookie后，利用此cookie在本地或服务器伪造原网站向后端发起恶意请求。于是为了防范此种行为，token就诞生了，首先他由后端随机生成一串数字并发送给前端，当前端向后端发起请求时，在携带cookie的同时，还要将之前的随机数字串即token一并发送给后端。\n第一步：后端随机产生一个token，把这个token保存在SESSION状态中；同时，后端把这个token交给前端页面；\n第二步：下次前端需要发起请求（比如发帖）的时候把这个token加入到请求数据或者头信息中，一起传给后端；\n第三步：后端校验前端请求带过来的token和SESSION里的token是否一致；\n添加用户 删除/修改用户 个人信息管理 修改个人信息 网站信息管理 修改网站信息 ","date":"2021-10-27T20:42:47Z","permalink":"https://www.bigcry.asia/p/%E6%9C%9F%E6%9C%AB%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95/","title":"期末博客系统扩展"},{"content":"虚拟机下的ArchLinux 安装实录(一) 获取镜像 -\u0026gt; 创建虚拟机 获取安装镜像 首先在 Archlinux.org 处选择适合的镜像与下载方式\n这里选择 163 源的下载镜像(ISO)\n创建虚拟机 选择自定义(高级) -\u0026gt; 下一步\n默认就好 -\u0026gt; 下一步\n选择刚刚下载好的镜像 -\u0026gt; 下一步\n操作系统选择 Linux , 版本根据自己下载的内核选择 , 这里选择 5.x 内核 -\u0026gt; 下一步\n根据自己情况选择安装位置 -\u0026gt; 下一步\n根据自己情况自行配置 , 也可后期更改 -\u0026gt; 下一步\n这里选择 NAT 连接方式 -\u0026gt; 下一步\n默认即可 -\u0026gt; 下一步\n视情况而定 , 这里选择 20G -\u0026gt; 下一步\n一直下一步直到出现完成界面 -\u0026gt; 完成\n更改启动模式 在虚拟机详情页面 ，点击进入虚拟机设置 ，进入 选项 选项卡 ，点击 高级 选项 ，在 固件类型 处选择 UEFI ，点击确定\nArch安装 安装菜单页面 开启刚创建的虚拟机\n这里选择 Arch Linux install medium, 敲回车[Enter]进入\n等待\u0026hellip;\u0026hellip; 进入Live默认Shell\n出现这个就代表进入成功了 ，如果没有进入 ，就要考虑是否镜像下载完整了\n键盘布局 初始键盘布局是标准的 QWERTY 布局 ，如果想更改布局 ，则输入以下命令查看支持的布局\nls /usr/share/kbd/keymaps/**/*.map.gz\n设置键盘布局为以下命令\nloadkeys 布局名称\n这里并不更改布局 ，进行下一步的安装\n验证启动模式 验证启动模式来为后面的 GRUB 引导安装做准备 ，输入以下命令\nls /sys/firmware/efi/efivars\n若正确显示为以下界面 ，则表示系统以 UEFI 模式启动 ，若提示目录不存在，则可能以 BIOS 或 CSM 等模式启动 ，本教程是以 UEFI 模式为基础的\n网络连接 虚拟机启动了 NAT 模式 ，所以默认是直接连接了网络的 ， 可以执行 ip link 命令查看网络信息 ， 执行 ping 命令查看网络连通情况\n时间校正 输入以下命令来确保系统时间准确\ntimedatectl set-ntp true\n可以使用 timedatectl status 来查看时间状态\n硬盘分区 分区是很重要的 ，这里也有几个坑\n建立分区 这里使用 fdisk 工具来建立分区\n输入 fdisk -l 查看硬盘信息 ，其中以 loop/rom/airoot 结尾的可以省略\n这里我的硬盘被识别并命名为 /dev/sda ， 记好这个名称 ， 接下来将在这块硬盘上进行分区\n输入 fdisk /dev/sda 进入分区命令界面 ， 可以输入 m 查看命令帮助\n这里输入 g 新建 GPT 分区表\n输入 n 来新建分区 ， 第一个分区我们把它作为一个 EFI 系统分区\n分区标识默认1即可 [Enter]， 分区开始 ，这里我们输入 2048 ，敲击回车\n结束标识 ，可以直接输入分区大小 ， boot分区不需要太大 ， 输入 +500M 即可 ，第一个分区建立完毕。\n接下来建立第二个分区 ， 我们把它作为 SWAP 交换空间的分区 ，可以理解为 win 的虚拟内存 , 依旧输入 n ，分区标识这里选择 3 ，因为我们打算 2 来作为主分区的标识 ，起始标识默认即可 ， 结束标识因为是作为交换空间来使用 ， 所以可以适当设置大一些 ，至此第二个分区建立完毕\n接下来建立主分区 ，输入 n ，分区标识默认 2 ，起始标识默认 ， 结束标识默认直到最后 ，至此三个分区全部建立完毕\n输入 w 来保存并退出分区\n可以再执行 fdisk -l 查看分区情况 ， 可以看到多出了三个新建的分区\n设置文件系统类型 接下来设置每个分区的文件系统与格式化\n这里注意: EFI系统分区的文件系统必须是FAT32的系统 ，如果是其他类型的系统 ， 会导致 GRUB 安装失败\n首先格式化 EFI 系统分区 ，输入 mkfs.fat -F32 /dev/sda1 来设置分区系统类型为 FAT32 并格式化\n接下来格式化并设置 SWAP 分区 ，输入 mkswap /dev/sda3 来初始化 SWAP 分区 ，接着输入 swapon /dev/sda3 激活 SWAP\n最后格式化主分区 ， 输入 mkfs.ext4 /dev/sda2 格式化并设置主分区格式\n挂载分区 接下来进行分区挂载 ， 首先将主分区挂载到 /mnt 目录 ，这也是根目录\nmount /dev/sda2 /mnt\n进行 EFI 系统分区 挂载\n1 2 mkdir /mnt/efi mount /dev/sda1 /mnt/efi 执行 lsblk 查看挂载情况\nSWAP 分区会自动挂载 ，所以无需设置\n安装系统镜像和软件包 设置源 因为不可抗力的情况 ，国内使用默认源会出现下载缓慢的情况 ，所以要设置国内源 ，比如清华源等 ，这里编辑 /etc/pacman.d/mirrorlist 可以设置国内镜像源 ， 这里我们添加清华源\n1 2 3 4 5 vim /etc/pacman.d/mirrorlist 添加一条记录 Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 更新源 pacman -Syy 安装软件包 使用 pacstrap 脚本 ， 安装 base 软件包和 linux 内核等等 ，新版Arch不带Vim等软件 ，所以也建议安装上 ，以及 dhcpcd , haveged 等\n最基本的套件为\n1 pacstrap /mnt base linux linux-firmware 可以直接执行我这条指令\n1 pacstrap /mnt base base-devel linux linux-firmware dhcpcd haveged 等待下载与安装完成 ，安装完成后进入系统配置\n系统配置 生成 fstab 文件\n1 2 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab cat /mnt/etc/fstab Chroot 进入新安装的系统\n1 arch-chroot /mnt 语言与时区设置 设置时区 1 2 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc 设置语言地区 1 2 3 4 5 6 7 8 9 10 vim /etc/locale.gen 找到需要的地区语言 ，将注释移除 如: en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 执行 locale-gen 生成locale信息 创建 locale.conf 文件 ，并添加 LANG=en_US.UTF-8 也可设置为中文 ，视情况而定 网络配置 编辑主机名称\n1 2 vim /etc/hostname XXX 编辑 hosts 添加\n1 2 3 4 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.0.1\tXXX.localdomain XXX # 其中XXX为上一步创建的主机名 设置 dhcpcd / haveged 开机启动\ndhcpcd 会自动分配ip\nhaveged 会在开机时自动搜集 系统熵 解决开机启动缓慢的问题\n1 2 systemctl enable dhcpcd systemctl enable haveged 用户设置 设置 root 密码\n1 passwd 添加一个用户并设置权限与密码\n1 2 3 4 5 # useradd -m -g users -s /bin/bash XXX passwd XXX vim /etc/sudoers 在 root ALL=(ALL) ALL 下添加一句 XXX ALL=(ALL) ALL 安装GRUB引导 安装 grub 和 efibootmgr 软件包\n1 pacman -S grub efibootmgr GRUB 安装 安装前使用 uname -a 查看自己的系统架构\n1 2 3 grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB # 注意 # --target后为你的系统架构 ，如我的为x86_64 ，--efi-directory后为你的 EFI系统分区地址 此处有一个小坑 ，若你的 EFI 系统分区 不是fat32类型 ， 就会安装失败\n如果为fat32仍安装失败 ， 可以用 gdisk 将分区设置 ef00\n如图所示 ， 即为安装完成\n生成配置文件 1 grub-mkconfig -o /boot/grub/grub.cfg 安装完成 退出新系统 , 重启\n1 2 exit reboot 进入新系统 ，开始愉快玩耍 使用AUR 既然用上了 Arch 不能不来用一下 AUR ，AUR 工具很多 ，这里选择 yay\n首先添加 pacman 的 archlinuxcn 源\n修改 /etc/pacman.conf ，在最后添加以下内容\n1 2 [archlinuxcn] Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 执行 pacman -Syy 更新源\n安装 archlinuxcn-keyring 来导入 GPG key\n安装 yay\n1 pacman -S yay 配置 AUR 源\n1 yay --aururl \u0026#34;https://aur.tuna.tsinghua.edu.cn\u0026#34; --save 剩下的就是愉快的安装软件与配置 ，接下来会更新美化 、配置等教程\n几个坑点 EFI 系统分区必须要是 FAT32 格式 新版arch貌似在安装后不包括 dhcpcd ，所以在执行安装安装脚本时请安装 dhcpcd 服务 ，否则只能进入 LiveCD 安装了 如果安装后开机启动缓慢 ，只停留一个界面光标闪烁 ，这是搜集系统熵的问题 ， 安装 haveged 并开启服务可解决 archlinux-keyring 安装失败 ，并提示 could not be locally signed(无法在本地签署) ， 请看这里 2020年8月11日\nby \u0026mdash;笑的心酸\n","date":"2020-08-10T23:23:10Z","permalink":"https://www.bigcry.asia/p/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B%E7%9A%84archlinux-%E5%AE%89%E8%A3%85%E5%AE%9E%E5%BD%95/","title":"虚拟机下的ArchLinux 安装实录(一)"},{"content":"1. node学习笔记day04 1.1. cheerio模块 cheerio是jquery核心功能的一个快速灵活而又简洁的实现，主要是为了用在服务器端需要对DOM进行操作的地方\n1.1.1. 安装 npm install cheerio\n1.1.2. 使用与示例 示例操作\n1 2 3 4 5 \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;hello world\u0026lt;/h1\u0026gt; \u0026lt;a href=\u0026#34;www.baidu.com\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;test\u0026#34;\u0026gt;test\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 使用 load 加载DOM，并返回一个 JQuery 对象\n1 2 3 4 5 6 7 8 9 let $ = cheerio.load(demo); console.log($(\u0026#34;.test\u0026#34;).text()); //输出 // PS E:\\LearnnodeJS\\day04\u0026gt; node .\\demo1.js // test console.log($(\u0026#34;a\u0026#34;).attr(\u0026#34;href\u0026#34;)); //输出 // PS E:\\LearnnodeJS\\day04\u0026gt; node .\\demo1.js // www.baidu.com 和 JQuery 操作基本相同\n1.2. axios 流模式返回 通过设置 responseType 属性为 stream ，生成流，可以来写入文件\n1.2.1. 使用和示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 axios .get(\u0026#34;https://xinsuan.xyz/\u0026#34;, { responseType: \u0026#34;stream\u0026#34; }) .then((res) =\u0026gt; { let ws = fs.createWriteStream(\u0026#34;./test.html\u0026#34;); res.data.pipe(ws); res.data.on(\u0026#34;close\u0026#34;, () =\u0026gt; { ws.close(); }); }) .catch((err) =\u0026gt; { console.error(err); }); 运行后写入 test.html 文件，如下 使用流模式可以实现下载文件等操作\n2. puppeteer 无界面谷歌浏览器 Puppeteer 是一个 Node 库，它提供了一个高级 API 来通过 DevTools 协议控制 Chromium 或 Chrome。Puppeteer 默认以 headless 模式运行，但是可以通过修改配置文件运行“有头”模式。\n具有以下功能:\n生成页面 PDF。 抓取 SPA（单页应用）并生成预渲染内容（即“SSR”（服务器端渲染））。 自动提交表单，进行 UI 测试，键盘输入等。 创建一个时时更新的自动化测试环境。 使用最新的 JavaScript 和浏览器功能直接在最新版本的Chrome中执行测试。 捕获网站的 timeline trace，用来帮助分析性能问题。 测试浏览器扩展 2.1. 示例与使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const puppeteer = require(\u0026#34;puppeteer\u0026#34;); async function test() { //生成浏览器对象 // headless 设置为 false 为有界面打开，默认无界面 let browser = await puppeteer.launch({ headless: false }); //生成页面对象 let page = await browser.newPage(); //打开页面 await page.goto(\u0026#34;https://www.xinsuan.xyz\u0026#34;); //页面内DOM操作 page.$$eval(\u0026#34;#one-words p\u0026#34;, (elements) =\u0026gt; { elements.forEach((element) =\u0026gt; { //浏览器控制台输出 console.log(element.innerHTML); }); }); //监听浏览器控制台事件 page.on(\u0026#34;console\u0026#34;, (...args) =\u0026gt; { //终端输出 console.log(args); }); } test(); 对DOM进行操作，聚焦或者点击\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const puppeteer = require(\u0026#34;puppeteer\u0026#34;); async function test() { let brower = await puppeteer.launch({ headless: false }); let page = await brower.newPage(); await page.goto(\u0026#34;http://www.baidu.com\u0026#34;); let wd = await page.$(\u0026#34;#form input[name = \u0026#39;wd\u0026#39;]\u0026#34;); await wd.focus(); await page.keyboard.type(\u0026#34;嘻嘻嘻\u0026#34;); let su = await page.$(\u0026#34;#form #su\u0026#34;); await su.click(); } test(); 2020年8月4日 by \u0026mdash; 笑的心酸\n","date":"2020-08-04T17:50:45Z","permalink":"https://www.bigcry.asia/p/nodejs%E5%AD%A6%E4%B9%A004/","title":"node学习笔记day04"},{"content":"1. node学习笔记day03 node 结合 os 模块与 axios 模块实现爬虫实战\n2. 目标 爬取B站用户追番信息，并保存为json文件形式\n2.1. 目标API 1 https://api.bilibili.com/x/space/bangumi/follow/list?type=1\u0026amp;follow_status=0\u0026amp;pn=?\u0026amp;ps=?\u0026amp;vmid=?\u0026amp;ts=? 2.2. url各参数解析 简要描述：\n获取指定用户订阅番剧信息 请求URL：\nhttps://api.bilibili.com/x/space/bangumi/follow/list 请求方式：\nGET 参数：\n参数名 必选 类型 说明 type 是 int 固定值 1 follow_status 是 int 固定值 0 pn 是 int 请求分页 ps 是 int 请求数据条数 , \u0026lt;50 vmid 是 int 用户Uid ts 否 int 时间戳 返回示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;code\u0026#34;: 0, \u0026#34;message\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;ttl\u0026#34;: 1, \u0026#34;data\u0026#34;: { \u0026#34;list\u0026#34;: [ { ... } ], \u0026#34;pn\u0026#34;: 1, \u0026#34;ps\u0026#34;: 1, \u0026#34;total\u0026#34;: 20 } } 返回参数说明\n参数名 类型 说明 code int 返回代码 message String 信息 data json 番剧数据 list array 详细信息 pn int 分页 ps int 返回数据条数 total int 总条数 3. axios 模块 3.1. 安装 安装axios模块，此模块基于Promise异步请求。简单方便 npm install axios\n3.2. 导入使用 1 const axios = require(\u0026#34;axios\u0026#34;); 4. 分析数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //获取番剧条数 let total = parseInt(res.data.data.total); //获取分页数 page = Math.ceil(total / params.ps); console.log(\u0026#34;page\u0026#34; + page); //迭代写入 res.data.data.list.forEach((el) =\u0026gt; { let postDetil = `\u0026#34;${el.season_id}\u0026#34;:{ \u0026#34;title\u0026#34;:\u0026#34; ${el.title}\u0026#34;, \u0026#34;count\u0026#34;: \u0026#34;${el.total_count}\u0026#34;, \u0026#34;season\u0026#34;: \u0026#34;${el.season_title}\u0026#34;, \u0026#34;evaluate\u0026#34;: \u0026#34;${el.evaluate.replace(/\\n/g, \u0026#34; \u0026#34;)}\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;${el.url}\u0026#34;, \u0026#34;data_show\u0026#34;: \u0026#34;${el.publish.release_date_show}\u0026#34; } `; bangmi[uid].push(postDetil); }); 5. 保存数据 1 2 3 4 5 let status = await f1( \u0026#34;./dist/\u0026#34; + uid + \u0026#34;/\u0026#34; + uid + \u0026#34;.json\u0026#34;, \u0026#34;{\\n\u0026#34; + bangmi[uid].toString() + \u0026#34;\\n}\u0026#34;, \u0026#34;a+\u0026#34; ); 6. 运行后截图 提示用户输入要爬取的id 返回json数据保存在本地 7. 全部代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 const axios = require(\u0026#34;axios\u0026#34;); const rs = require(\u0026#34;readline\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); var vmid; var url = \u0026#34;https://api.bilibili.com/x/space/bangumi/follow/list?\u0026#34;; var params = { type: 1, follow_status: 0, pn: 0, ps: 15, vmid: vmid, }; var bangmi = {}; //封装写入操作 function f1(path, data, flag) { return new Promise((res, ract) =\u0026gt; { fs.writeFile(path, data, { flag: flag, encoding: \u0026#34;utf-8\u0026#34; }, (err) =\u0026gt; { if (err) ract(err); res(\u0026#34;写入完毕\u0026#34;); }); }); } //声明用户输入操作 var r1 = rs.createInterface({ input: process.stdin, output: process.stdout, }); //封装读取用户输入操作 function read(title) { return new Promise((res) =\u0026gt; { r1.question(title, (answer) =\u0026gt; { res(answer); }); }); } //声明初始化方法 async function init() { let uid = await read(\u0026#34;查询的用户UID:\u0026#34;); params.vmid = uid; bangmi[uid] = []; //判断用户文件夹是否已存在 if (!fs.existsSync(\u0026#34;./dist/\u0026#34; + uid)) { fs.mkdir(\u0026#34;./dist/\u0026#34; + uid, (err) =\u0026gt; { if (err) console.log(err); }); } //定义循环控制次数与分页 var i = 1; var page; do { await axios .get( url + \u0026#34;type=\u0026#34; + params.type + \u0026#34;\u0026amp;follow_status=\u0026#34; + params.follow_status + \u0026#34;\u0026amp;pn=\u0026#34; + params.pn + i + \u0026#34;\u0026amp;ps=\u0026#34; + params.ps + \u0026#34;\u0026amp;vmid=\u0026#34; + params.vmid ) .then((res) =\u0026gt; { //获取番剧条数 let total = parseInt(res.data.data.total); //获取分页数 page = Math.ceil(total / params.ps); console.log(\u0026#34;page\u0026#34; + page); //迭代写入 res.data.data.list.forEach((el) =\u0026gt; { let postDetil = `\u0026#34;${el.season_id}\u0026#34;:{ \u0026#34;title\u0026#34;:\u0026#34; ${el.title}\u0026#34;, \u0026#34;count\u0026#34;: \u0026#34;${el.total_count}\u0026#34;, \u0026#34;season\u0026#34;: \u0026#34;${el.season_title}\u0026#34;, \u0026#34;evaluate\u0026#34;: \u0026#34;${el.evaluate.replace(/\\n/g, \u0026#34; \u0026#34;)}\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;${el.url}\u0026#34;, \u0026#34;data_show\u0026#34;: \u0026#34;${el.publish.release_date_show}\u0026#34; } `; bangmi[uid].push(postDetil); }); i++; }); } while (i \u0026lt;= page); //写入json文件 let status = await f1( \u0026#34;./dist/\u0026#34; + uid + \u0026#34;/\u0026#34; + uid + \u0026#34;.json\u0026#34;, \u0026#34;{\\n\u0026#34; + bangmi[uid].toString() + \u0026#34;\\n}\u0026#34;, \u0026#34;a+\u0026#34; ); console.log(status); //关闭输入 r1.close(); } init(); 2020/7/23 by \u0026mdash;笑的心酸\n","date":"2020-07-23T19:13:05Z","permalink":"https://www.bigcry.asia/p/nodejs%E5%AD%A6%E4%B9%A003/","title":"node实战项目--B站爬虫"},{"content":"1. node学习笔记day02 2. node文件流 流的出现是为了解决读取文件时，文件内容过于庞大而造成计算机内存不够导致的问题 其将庞大文件分为多个流，以流的形式经由内存写入磁盘\n2.1. 读取流 createReadStream来自node的fs模块，此方法将创建一个输出流\n2.2. 写入流 createWriteStream此方法将创建一个输入流\n2.3. node管道流 pipe 创建管道，并将输出流中的数据通过管道插入到输入流中\n3. node事件 1 2 3 4 5 6 7 Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。 Node.js 几乎每一个 API 都是支持回调函数的。 Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。 Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数. 3.1. 原生js写事件绑定与监听 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 var userEvent = { eventName:{ //事件列表 }, on:function(ent,fn) { //绑定事件 if (this.eventName[ent]) { this.eventName[ent].push(fn) } else { this.eventName[ent] = []; this.eventName[ent].push(fn) } }, emit:function(ent,msg) { //监听事件 if (this.eventName[ent]) { this.eventName[ent].forEach(element =\u0026gt; { element(msg) }); } }, delent:function(ent) { //删除事件 if (this.eventName[ent]) { delete this.eventName[ent] } else { console.log(\u0026#34;err\u0026#34;) } } } 调用原生js事件\n1 2 3 4 5 6 7 8 //绑定一个名为success的事件，该事件接受一个参数并输出 userEvent.on(\u0026#39;success\u0026#39;,(msg)=\u0026gt;{ console.log(msg) }) //调用success事件，并传入参数 userEvent.emit(\u0026#39;success\u0026#39;,\u0026#39;done\u0026#39;) //删除success事件 userEvent.delent(\u0026#39;success\u0026#39;) 3.2. node事件模块 1 2 3 4 5 6 7 8 9 10 11 12 const events = require(\u0026#39;events\u0026#39;); //创建一个事件对象 let evt = new events.EventEmitter(); //绑定click事件，该事件接受一个参数并输出 evt.on(\u0026#39;click\u0026#39;,(data)=\u0026gt;{ console.log(\u0026#34;wow\u0026#34;+data) }) //监听click并调用，传入一个参数 evt.emit(\u0026#39;click\u0026#39;,\u0026#39;good\u0026#39;); 4. node路径模块 path\n4.1. 路径片段组合 1 2 3 4 5 6 7 const path = require(\u0026#39;path\u0026#39;) let arr = [\u0026#39;/\u0026#39;,\u0026#39;ts\u0026#39;,\u0026#39;keke\u0026#39;] let ps = path.join(...arr) console.log(ps) //输出\\ts\\keke 5. node OS模块 1 2 3 4 5 const os = require(\u0026#39;os\u0026#39;) let osc = os.cpus(); console.log(osc) 6. node URL 模块 6.1. 解析url地址并返回对象 parse\n1 2 3 4 5 6 7 8 9 const url = require(\u0026#39;url\u0026#39;) console.log(url); let Bilibili = \u0026#34;https://www.bilibili.com/video/BV1i7411G7kW?p=9\u0026#34;; let urlObj = url.parse(Bilibili); console.log(urlObj); 7. axios 基于promise的HTTP库，跨平台，轻量级，vue指定\n7.1. 特性 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 7.2. 安装 npm install axios\n7.3. 导入使用 示例：get请求\n1 2 3 4 5 6 7 axios.get(url,params) .then(res =\u0026gt; { console.log(res) }) .catch(err =\u0026gt; { console.error(err); }) 8. request 模块 官网介绍自2020年2月份以来，本模块已弃用\u0026hellip; 不过还是要了解了解\n8.1. 安装 npm install request\n8.2. 导入使用 示例：简单get请求\n1 2 3 4 5 req.get(\u0026#34;https://www.baidu.com\u0026#34;,(err,response,body)=\u0026gt;{ if (err) console.log(err) console.log(response) console.log(body) }) 8.3. 封装 1 2 3 4 5 6 7 8 function reqGet(url) { return new Promise((reslove, reject) =\u0026gt; { req.get(url, (err, response, body) =\u0026gt; { if (err) reject(err) reslove({response,body}) }) }) } 2020年7/21 by 笑的心酸\n","date":"2020-07-21T19:53:30Z","permalink":"https://www.bigcry.asia/p/nodejs%E5%AD%A6%E4%B9%A002/","title":"node学习笔记day02"},{"content":"hexo升级实录 今天升级了nodeJS到14版本，然后使用hexo时出现如下警告\n1 2 3 4 5 6 7 (node:17352) Warning: Accessing non-existent property \u0026#39;lineno\u0026#39; of module exports inside circular dependency (Use `node --trace-warnings ...` to show where the warning was created) (node:17352) Warning: Accessing non-existent property \u0026#39;column\u0026#39; of module exports inside circular dependency (node:17352) Warning: Accessing non-existent property \u0026#39;filename\u0026#39; of module exports inside circular dependency (node:17352) Warning: Accessing non-existent property \u0026#39;lineno\u0026#39; of module exports inside circular dependency (node:17352) Warning: Accessing non-existent property \u0026#39;column\u0026#39; of module exports inside circular dependency (node:17352) Warning: Accessing non-existent property \u0026#39;filename\u0026#39; of module exports inside circular dependency 并且构建文件错误，遂想到是因为node版本与当前hexo不匹配的原因，进到hexo的官网发现其发布了新的版本，所以应升级尝试一下 hexo升级分为以下四步，还是很简单的\n使用npm升级命令 npm -i hexo -g ，但是并无效果 安装npm-check: npm install -g npm-check，并使用该命令来检查插件版本 安装npm-upgrade : npm install -g npm-upgrade,并使用该命令来升级插件 使用npm update -g 与 npm update --save命令 此时全局hexo升级完成，但是用来发布博客的版本尚未升级 此时应新建一个博客文件夹，执行hexo init命令，然后将旧博客的配置文件:package.json 、 _config.yml 以及 主题文件 、md文章复制到新的博客文件夹相应位置中 然后在新目录下执行 npm update --save来安装/升级所需依赖 此时hexo升级工作完成\n","date":"2020-07-18T19:49:33Z","permalink":"https://www.bigcry.asia/p/hexo%E5%8D%87%E7%BA%A7%E5%AE%9E%E5%BD%95/","title":"hexo升级实录"},{"content":"1. node学习笔记day01 2. node简介 是一个运行js的环境 , 不是一门新的语言 , 不是js的框架 , 而是独立于浏览器来运行js的环境或js编译器 , 采用谷歌的V8引擎 , node可以用来写后端及操作文件或数据库 , 使js更强 node中可以输出一下window/document对象 , 会发现没有定义 , 这是因为这两个对象都是浏览器环境下的 , 而node作为一个独立环境是不存在这两个对象的定义的\n1 2 console.log(window); //node报错：ReferenceError: window is not defined 3. node安装 百度node官网 , 下载安装包 , 安装完成自动配置环境变量 , 控制台输入node -v来检测node是否安装成功及查看node版本\n4. node运行js文件 可在命令行使用node命令之后 , 输入js语句 , 回车运行 , 也可输入node XX.js来运行js文件\n5. node运行示例 1 2 3 4 5 6 7 8 9 10 11 12 13 class user { constructor(){ this.name = \u0026#34;小明\u0026#34;; this.pwa = \u0026#34;123456\u0026#34;; } toString() { return this.name+\u0026#34; \u0026#34;+this.pwa; } } var u1 = new user(); console.log(u1.toString()); 保存为文件后 , 使用node xx.js运行后结果\n1 2 PS E:\\LearnnodeJS\\day01\u0026gt; node .\\test.js 小明 123456 6. node模块化 可跨文件使用变量或对象等 , 每个文件都可以看作一个模块 使用commonJS规范 , 包含三个关键字：require、exports、module js导出某对象：exports.name = name (xx.js) js导入某对象：var name = require('/xx.js') (test.js) 模块化示例：\n1 2 3 4 5 6 7 8 9 10 //xx.js 导出模块 var user = { name:\u0026#34;zs\u0026#34;, sex:\u0026#34;man\u0026#34;, age:12 } exports.user = user; //或使用 module.exports.user = user; 1 2 3 //test.js 导入xx模块 var u2 = require(\u0026#39;./xx.js\u0026#39;); console.log(u2.user.name); 输出结果\n1 2 PS E:\\LearnnodeJS\\day01\u0026gt; node .\\test.js zs exports 本质上是指向了 module.exports , 所以两者使用没有区别 , 但要注意如果不小心重写了exports , 如：exports = {user:\u0026quot;zs\u0026quot;} 此时exports不在指向module.exports , 而是被重写为一个对象或属性 , 此时将没有了导出功能 , 所以以下方法：\n1 2 3 4 exports = {user:\u0026#34;zs\u0026#34;} //错误的 , 将改变指向 , 不具备导出功能 //运行后输出 : {} module.exports = {user:\u0026#34;zs\u0026#34;} //正确的 , 将导出一个对象 //运行后输出 : { user: \u0026#39;zs\u0026#39; } 其两种的运行结果不同 , 所以应尽量使用module.exports来进行模块的导出 模块导入后会在内存中产生缓存 , 下次导入时若缓存中存在 , 将直接获取 , 若想重新导入 , 就要清除缓存\n1 2 3 4 var a = require(\u0026#39;./xx\u0026#39;); var b = require(\u0026#39;./xx\u0026#39;); console.log(a == b); //将输出 true 这是因为模块导入形成缓存 , 在第二次导入时 , 将直接在缓存中拿取 , 不会产生新对象\n7. node的require加载机制 require中关于路径： 若为require('/home/xx.js') , 将前往磁盘根目录下层级寻找 //绝对 若为require('./xx.js') , 将在主模块文件下寻找 //相对 若为require('xx') , 将视为加载第三方模块 , 其加载顺序为 :\n首先查看当前目录下的node_modules文件夹 , 若当前目录下没有，则去父级目录查找，一直找到磁盘根目录 在node_modules中查找第三方模块名称文件夹 , 若找到，则进入该文件夹，查看文件间内的package.json文件，查找其main属性内容，并将其内容作为第三方模块的主入口 若没有main属性，则默认加载第三方模块文件夹内的index.js文件 8. node对于文件的操作 导入文件操作模块fs , 其中文件操作有同步与异步两种方式，node默认异步操作\n8.1. 对文件的读取操作 readFile/readFileSync方法，异步与同步\n8.1.1. 同步 1 2 3 4 //ts.txt 内容：hello var f1 = fs.readFileSync(\u0026#39;ts.txt\u0026#39;,{flag:\u0026#39;r\u0026#39;,encoding:\u0026#39;utf-8\u0026#39;}); console.log(f1) //输出：hello readFileSync(path,[options]) 参数列表：\npath ( 所读取文件目标路径 ) : \u0026lt;String | number | Buffer\u0026gt; options ( 文件属性,可选参数 ) : \u0026lt;Object | String\u0026gt; flag ( 对文件的操作 ) : 默认值 \u0026lsquo;r\u0026rsquo; encoding ( 文件编码 ) : 默认值 \u0026rsquo;null' 8.1.2. 异步 1 2 3 4 fs.readFile(\u0026#39;ts.txt\u0026#39;,{flag:\u0026#39;r\u0026#39;,encoding:\u0026#39;utf-8\u0026#39;},(err,data)=\u0026gt;{ if (err) throw err; //出现异常抛出 console.log(data); //成功打印内容：hello }) readFile(path,[options],callback) 参数列表：\npath ( 所读取文件目标路径 ) : \u0026lt;String | number | Buffer\u0026gt; options ( 文件属性,可选参数 ) : \u0026lt;Object | String\u0026gt; flag ( 对文件的操作 ) : 默认值 \u0026lsquo;r\u0026rsquo; encoding ( 文件编码 ) : 默认值 \u0026rsquo;null' callback ( 回调函数 ) : err : 出错 data : 内容 8.1.3. 封装 1 2 3 4 5 6 7 8 9 10 11 12 function f2(path) { return new Promise((res,rect)=\u0026gt;{ fs.readFile(path,{flag:\u0026#39;r\u0026#39;,encoding:\u0026#39;utf-8\u0026#39;},(err,data)=\u0026gt;{ if (err) rect(err) res(data) }) }) } f2(\u0026#39;ts.txt\u0026#39;).then((res)=\u0026gt;{ console.log(res) }) 8.2. 对文件的写入操作 writeFile/writeFileSync方法，异步与同步 写入文件若不存在，将自动创建文件\n8.2.1. 同步 1 fs.writeFileSync(\u0026#39;ts.txt\u0026#39;,\u0026#39;world\u0026#39;,{flag:\u0026#39;a+\u0026#39;,encoding:\u0026#39;utf-8\u0026#39;}); writeFileSync(path,data,[options]) 参数列表：\npath ( 所读取文件目标路径 ) : \u0026lt;String | number | Buffer | URL\u0026gt; data ( 写入的数据 ) : \u0026lt;String | \u0026hellip;\u0026gt; options ( 文件属性,可选参数 ) : \u0026lt;Object | String\u0026gt; flag ( 对文件的操作 ) : 默认值 \u0026lsquo;w\u0026rsquo;; \u0026lsquo;w\u0026rsquo;为覆盖写入; \u0026lsquo;a+\u0026lsquo;为追加写入 encoding ( 文件编码 ) : 默认值 \u0026rsquo;null\u0026rsquo; 8.2.2. 异步 1 2 3 4 fs.writeFile(\u0026#39;ts.txt\u0026#39;,\u0026#39;World--Sync\u0026#39;,{flag:\u0026#39;a+\u0026#39;,encoding:\u0026#39;utf-8\u0026#39;},(err)=\u0026gt;{ if (err) console.log(err) console.log(\u0026#34;done\u0026#34;); }) writeFile(path,data,[options],callback) 参数列表：\npath ( 所读取文件目标路径 ) : \u0026lt;String | number | Buffer | URL\u0026gt; data ( 写入的数据 ) : \u0026lt;String | \u0026hellip;\u0026gt; options ( 文件属性,可选参数 ) : \u0026lt;Object | String\u0026gt; flag ( 对文件的操作 ) : 默认值 \u0026lsquo;w\u0026rsquo;; \u0026lsquo;w\u0026rsquo;为覆盖写入; \u0026lsquo;a+\u0026lsquo;为追加写入 encoding ( 文件编码 ) : 默认值 \u0026rsquo;null\u0026rsquo; callback ( 回调函数 ) : err ( 出现错误 ) : 8.2.3. 封装 1 2 3 4 5 6 7 8 9 10 11 12 function f1(path,data,flag) { return new Promise((res,ract)=\u0026gt;{ fs.writeFile(path,data,{flag:flag,encoding:\u0026#39;utf-8\u0026#39;},(err)=\u0026gt;{ if (err) ract(err) res(\u0026#34;写入完毕\u0026#34;) }) }) } async function f() { await f1(\u0026#39;test.html\u0026#39;,\u0026#39;\u0026lt;h1\u0026gt;ddddd\u0026lt;/h1\u0026gt;\u0026#39;,\u0026#39;a+\u0026#39;); } 8.3. 其他操作 unlink : 删除文件操作 mkdir : 创建目录 readdir : 读取目录 rmdir : 删除目录 \u0026hellip;等等 中文文档\n9. node 输入输出 9.1. 输入 readLine\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var readline = require(\u0026#39;readline\u0026#39;) var r1 = readline.createInterface({ input:process.stdin, output:process.stdout }) r1.question(\u0026#39;整点啥\u0026#39;,(answer)=\u0026gt;{ console.log(answer) r1.close(); }) r1.on(\u0026#39;close\u0026#39;,()=\u0026gt;{ process.exit(0); }) createInterface : 创建输入输出对象，调用了终端进程的输入输出 input:process.stdin : 创建输入 output:process.stdout : 创建输出 question : 提问方法，使用完毕后应关闭输入流，否则程序不会终止 close : 关闭输入流 on : 监听事件，并作出响应 process.exit(0) : 退出终端进程\n9.2. 封装 1 2 3 4 5 6 7 function read(title) { return new Promise((res)=\u0026gt;{ r1.question(title,(answer)=\u0026gt;{ res(answer) }) }) } 10. 常用npm命令 node -v 查看node版本 npm init 自动在目录下生成package.json文件，加入-y可跳过问答 npm -v 查看npm版本 npm list 查看当前目录下安装的包，加入-g查看全局安装的包 npm config list 查看配置信息 npm install 包名 自动安装包及其所需依赖 npm install 包名 --save -dev 安装包的开发环境所需依赖 npm install 包名 --save 安装包的生产环境所需依赖 npm uninstall 包名 卸载某个包\n2020/07/17 by \u0026mdash;- 笑的心酸\n","date":"2020-07-17T16:41:54Z","permalink":"https://www.bigcry.asia/p/nodejs%E5%AD%A6%E4%B9%A001/","title":"node学习笔记day01"},{"content":"前言 假设以下操作你已经拥有了自己的域名与服务器\nhexo安装与基本语法 安装前环境配置:nodejs 前往nodejs官网下载所需版本，安装即可 安装好后打开终端输入node -v,出现以下代码即表示安装成功 hexo 配置 在终端中输入npm install hexo-cli -g，回车等待安装完成 安装成功后输入hexo -v回车，出现以下代码即表示安装成功 新建或选择一个储存博客文件的文件夹 在文件夹下打开终端，输入hexo init回车，hexo即可在当前目录下生成博客所需的文件，稍作等待后，即可新建完成 目录结构为\n1 2 3 4 5 6 7 8 . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 其余命令自行查询hexo官方文档 接下来安装hexo的git插件来使hexo对git支持 在当前目录下输入npm install hexo-deployer-git --save回车即可安装 接下来配置服务器方面\n阿里云方面配置 下列操作以Centos7系统为代表 安装nginx、git过程省略 选择/新建一个目录来作为自己博客文件存储的地方 修改权限为：chmod -R 777 /XXX/XXX/blog/ 新建一个用来发布博客的工具用户adduser git,修改他的权限 执行下列命令\n1 2 chmod 740 /etc/sudoers vim /etc/sudoers 在打开的文档中找到root ALLALL=() ALL,在他的下面添加一行git ALLALL=() ALL,保存退出 输入sudo passswd git为git用户设置密码及解除锁定\nnginx的配置 进入nginx的安装目录，输入vim conf/nginx.conf回车，即可打开nginx的配置文件,修改端口80的参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 server { listen 80; //监听的端口 server_name www.xinsuan.xyz; //匹配主机名，例如访问的为www.xinsuan.xyz,自动匹配成功后转发到相应的服务器中 #access_log logs/host.access.log main; location / { root /XXX/XXXX/blog; //网站主目录，这里改为要存储博客的目录 index index.html index.htm; //匹配网站主页文件 expires 7d; //缓存设置 (可选) } ... } 至此，nginx方面配置结束\nGit配置 输入su git切换到新建的git用户，选择/新建一个目录来作为远程仓库配合博客发布使用 在新建的目录中输入git init --bare XXX.git ，其中XXX为自定义名字，配置目录权限\n1 chmod -R 777 XXX.git 进入XXX.git目录下的hooks目录，新建钩子文件post-receive,编辑文件\n1 2 3 4 #!/bin/sh git --work-tree=存储博客目录 --git-dir=刚刚新建的远程仓库目录 checkout -f 例如：git --work-tree=/usr/bin/blog --git-dir=/usr/repo/XXX.git checkout -f 这个文件就是当文件上传到远程仓库后自动转发 接下来给文件以运行权限\n1 chmod +x post-receive ###配置sshKey实现免密登录 服务端输入以下命令：mkdir ~/.ssh、vim ~/.ssh/authorized_keys\n本机进入C:\\Users\\XXX\\.ssh目录，如果没有则需要git生成sshKey 输入以下命令\n1 2 3 4 git config --global user.name \u0026#34;username\u0026#34; //配置用户名 git config --global user.email \u0026#34;useremail\u0026#34; //配置邮箱 ssh-keygen -t rsa -C \u0026#34;useremail\u0026#34; //生成公钥与私钥,过程中连按三次回车即可，无需设置密码等 再次进入C:\\Users\\XXX\\.ssh，查看id_rsa.pub中的内容(公钥)，将其复制到服务器刚刚新建的authorized_keys文件中，保存退出。 至此，服务器方面暂时结束\n配置GIthub与hexo 进入hexo博客目录，打开_config.yml文件，这是hexo的配置文件，具体配置参考官方文档，这里只说一下关于git方面的配置 修改文件中的以下内容\n1 2 3 4 5 deploy: type: git repo: git@远程仓库地址/ip:/usr/repo/XXX.git //远程仓库地址 //例如：git@10.10.10.10:/usr/repo/blog.git branch: master //分支选择master即可 实现自动发布 接下来就是自动发布了，新建一篇文章，输入以下命令即可自动发布\n1 2 hexo new \u0026#34;新建文章\u0026#34; hexo clean \u0026amp;\u0026amp; hexo d -g //构建并推送至远程仓库，到达远程仓库后触发hooks，自动将文件转发到了博客目录，实现自动化 收尾工作 将git用户权限限制，切换到root用户，编辑/etc/passwd,在最后添加一句\n1 2 git:x:1000:1000::/home/git:/usr/bin/git-shell //这是限制该用户只能使用git-shell，所以并不能登录等其他操作，只是一个发布文章的工具用户 其余修改hexo主题、各种hexo插件等，后期介绍\n参考文档 hexo官方文档\n","date":"2020-07-01T22:14:01Z","permalink":"https://www.bigcry.asia/p/hexo%E5%AE%89%E8%A3%85/","title":"hexo+Github+阿里云实现个人博客与自动发布"},{"content":"关于新版Windows Terminal 简介 Windows 终端是一个面向命令行工具和 shell（如命令提示符、PowerShell 和适用于 Linux 的 Windows 子系统 (WSL)）用户的新式终端应用程序。 它的主要功能包括多个选项卡、窗格、Unicode 和 UTF-8 字符支持、GPU 加速文本呈现引擎，还可以用于创建你自己的主题并自定义文本、颜色、背景和快捷键绑定。 下载与安装 下载途径有两种： 需要系统版本190X及以上 可在微软商店内搜索下载 亦可在GitHub发布页下载 需要注意：git处有两种版本 第一个为预览版 ，第二个为稳定版，请自行选择下载 安装界面如图(因为我这里已经安装了所以显示为启动，正常应为安装): 美化准备工作 PowerShell7 良好的网络环境 PowerShell7安装 在PowerShell处选择对应系统下载 其中LTS为长期更新版本, stable 稳定版本，preview预览版本\n将Terminal添加到右键菜单 这里有两种方式修改:\n通过修改注册表(不推荐) 使用git上的一键脚本配置 这里着重说明一下第二种方式(下列操作默认管理员身份运行) 点击一键脚本跳转页面 注意需要PowerShell版本为7 可下载install.sp1文件然后在PowerShell7中找到文件执行命令 .\\install.ps1 亦可采用git页面给出的命令安装\n1 Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://raw.githubusercontent.com/lextm/windowsterminal-shell/master/install.ps1\u0026#39;)) 注意：可能会报下列错误\n.\\install.ps1: File C:\\Users\\lenovo\\Desktop\\install.ps1 cannot be loaded because running scripts is disabled on this system. For more information, see about_Execution_Policies at https://go.microsoft.com/fwlink/?LinkID=135170.\n这是因为PowerShell默认执行权限的问题,此时只需打开PowerShell输入下列命令即可:\n1 set-ExecutionPolicy RemoteSigned Windows Terminal配置文件更改 打开Windows Terminal，点击标题栏小三角，打开设置页面 目前官方仍未更新GUI页面，所以打开为一个JSON文件 将PowerShell7添加至Windows Terminal启动菜单 在配置文件中修改以下属性 属性名称:list 在其中添加:\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;guid\u0026#34;: \u0026#34;{574e775e-4f2a-5b96-ac1e-a2962a402336}\u0026#34;, //程序对应的guid属性唯一值 \u0026#34;hidden\u0026#34;: false, //是否在启动列表隐藏 \u0026#34;name\u0026#34;: \u0026#34;pwsh7\u0026#34;, //启动列表名称 \u0026#34;tabTitle\u0026#34;: \u0026#34;pwsh7\u0026#34;, //选项卡标题名称 \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.PowershellCore\u0026#34;, //这会存储源自配置文件的配置文件生成器的名称 \u0026#34;startingDirectory\u0026#34;: \u0026#34;.\u0026#34;, //加载 shell 时所处的起始目录 这一步一定要设为\u0026#39;.\u0026#39;，否则会影响后续操作 \u0026#34;historySize\u0026#34;: 9001, //历史记录大小 \u0026#34;commandline\u0026#34;: \u0026#34;C:/Program Files/PowerShell/7/pwsh.exe -nologo\u0026#34;, //配置文件中使用的可执行文件 \u0026#34;snapOnInput\u0026#34;: true //键入时滚动到输入行 } 其中guid生成可以点击此处\n修改默认启动shell 此时我们修改默认的启动shell为新安装的PowerShell7\n属性名称: defaultProfile 属性值: 对应shell的guid属性\n将此值改为我们上方设置的PowerShell7的guid\n修改字体，背景及配色方案等 在profiles 属性下的 defaults属性中添加/修改些默认参数:\n1 2 3 4 5 6 7 8 { \u0026#34;acrylicOpacity\u0026#34;: 0.25, //设置背景模糊度 \u0026#34;useAcrylic\u0026#34;: true, //开启背景毛玻璃效果 \u0026#34;colorScheme\u0026#34;: \u0026#34;Monokai Night\u0026#34;, //设置配色方案，需要搭配后面的配色方案使用 \u0026#34;suppressApplicationTitle\u0026#34;:true, //启动自定义选项卡标题 \u0026#34;fontSize\u0026#34;: 11, //字体大小 \u0026#34;fontFace\u0026#34;: \u0026#34;Fira Code\u0026#34;, //设置字体 } 字体修改： 选择喜欢的字体下载(最好是支持PowerLine的，否则后续会出现字符渲染的问题) 这里以Fira Code字体为例 点击此处开始下载Fira Code 安装好字体后，在defaults属性中添加\u0026quot;fontFace\u0026quot;: \u0026quot;Fira Code\u0026quot;值\n配色方案修改: 下方网址寻找喜欢的配色方案 terminalsplash atomcorp 多种配色方案，此处以第一个网址为例，进入后等待加载完毕 选择喜欢的配色方案，点击code 复制弹出的代码 粘贴至配置文件的schemes属性中 如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026#34;schemes\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;Monokai Night\u0026#34;, //配色方案名称 \u0026#34;background\u0026#34;: \u0026#34;#1f1f1f\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#f8f8f8\u0026#34;, \u0026#34;black\u0026#34;: \u0026#34;#1f1f1f\u0026#34;, \u0026#34;blue\u0026#34;: \u0026#34;#6699df\u0026#34;, \u0026#34;cyan\u0026#34;: \u0026#34;#e69f66\u0026#34;, \u0026#34;green\u0026#34;: \u0026#34;#a6e22e\u0026#34;, \u0026#34;purple\u0026#34;: \u0026#34;#ae81ff\u0026#34;, \u0026#34;red\u0026#34;: \u0026#34;#f92672\u0026#34;, \u0026#34;white\u0026#34;: \u0026#34;#f8f8f2\u0026#34;, \u0026#34;yellow\u0026#34;: \u0026#34;#e6db74\u0026#34;, \u0026#34;brightBlack\u0026#34;: \u0026#34;#75715e\u0026#34;, \u0026#34;brightBlue\u0026#34;: \u0026#34;#66d9ef\u0026#34;, \u0026#34;brightCyan\u0026#34;: \u0026#34;#e69f66\u0026#34;, \u0026#34;brightGreen\u0026#34;: \u0026#34;#a6e22e\u0026#34;, \u0026#34;brightPurple\u0026#34;: \u0026#34;#ae81ff\u0026#34;, \u0026#34;brightRed\u0026#34;: \u0026#34;#f92672\u0026#34;, \u0026#34;brightWhite\u0026#34;: \u0026#34;#f8f8f2\u0026#34;, \u0026#34;brightYellow\u0026#34;: \u0026#34;#e6db74\u0026#34; }] 修改默认配色方案colorScheme属性值为自定义的配色方案名称\n背景修改： 开启背景毛玻璃效果 1 2 \u0026#34;acrylicOpacity\u0026#34;: 0.25, //设置背景模糊度 \u0026#34;useAcrylic\u0026#34;: true, //开启毛玻璃效果 设置背景图片 1 2 3 4 5 \u0026#34;backgroundImage\u0026#34;:\u0026#34;图片路径\u0026#34;, \u0026#34;backgroundImageStretchMode\u0026#34;:\u0026#34;背景拉伸\u0026#34;, //可选属性: \u0026#34;none\u0026#34;、\u0026#34;fill\u0026#34;、\u0026#34;uniform\u0026#34;、\u0026#34;uniformToFill\u0026#34; \u0026#34;backgroundImageAlignment\u0026#34;:\u0026#34;背景对齐方式\u0026#34;,//可选属性: \u0026#34;center\u0026#34;、\u0026#34;left\u0026#34;、\u0026#34;top\u0026#34;、\u0026#34;right\u0026#34;、\u0026#34;bottom\u0026#34;、 //\u0026#34;topLeft\u0026#34;、\u0026#34;topRight\u0026#34;、\u0026#34;bottomLeft\u0026#34;、\u0026#34;bottomRight\u0026#34; \u0026#34;backgroundImageOpacity\u0026#34;:\u0026#34;背景不透明度\u0026#34;, //0-1 其他属性如滚动条，光标颜色等可参考官方文档链接 PowerShell配置 新版的PowerShell虽然功能更新不少，但默认的操作和界面比较不耐看，此时我们便需要借助一些插件来完善他\nPowerShell插件配置 使用管理员身份打开PowerShell 依次输入下方三个命令安装插件\n1 2 3 Install-Module -Name PSReadLine -AllowPrerelease -Force Install-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser 然后输入以下命令来配置插件\n1 notepad.exe $PROFILE 这会打开默认PowerShell 的启动配置文件，如果提示没有该文件，点击创建就好 在打开的文件中输入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 引入 posh-git Import-Module posh-git # 引入 oh-my-posh Import-Module oh-my-posh #引入 PSReadLine Import-Module PSReadLine # 设置 PowerShell 主题 Set-Theme Paradox #设置 Tab 键补全 Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete # 设置 Ctrl+d 为退出 PowerShell Set-PSReadlineKeyHandler -Key \u0026#34;Ctrl+d\u0026#34; -Function ViExit # 设置 Ctrl+z 为撤销 Set-PSReadLineKeyHandler -Key \u0026#34;Ctrl+z\u0026#34; -Function Undo # 设置向上键为后向搜索历史记录 Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向下键为前向搜索历史纪录 Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward 亦可参考官方样例来自行修改\n使PowerShell支持git bash 此时修改的已经差不多了，但PowerShell的git功能仍有一些缺陷 我们需要修改环境变量，使PowerShell更上一层楼 将git Bash目录下的usr/bin路径复制进去就好了\n后记 这是我的第一篇文章，自微软Bulid 2019以来，宣布新的终端Windows Terminal，我就一直在关注，并第一时间下下来使用，那时的Windows Terminal充满bug，动不动就会闪退，蛋疼的操作，蛋疼的配置，让我着实没能香起来，最近Bulid 2020大会，微软正式推出Windows Terminal 1.0正式版，迫不及待下载后，一个字，香，两个字，真香，虽然还有一些小瑕疵，譬如图形化配置界面，还整json文件呢，真就人均极客了嗷。并没有使用过cmder、Xshell等第三方终端，所以以上观点仅代表个人审美。溜了溜了\n顺便这篇文章的生成与发布均使用新版Windows Terminal\n参考文献: 微软官方文档 如何打造好看还好用的 Windows Terminal\u0026mdash;ChrAlpha 5 个 PowerShell 主题，让你的 Windows 终端更好看\u0026mdash;少数派\n","date":"2020-06-09T10:14:58Z","permalink":"https://www.bigcry.asia/p/windows-terminal%E7%BE%8E%E5%8C%96%E9%85%8D%E7%BD%AE/","title":"新版Windows Terminal美化配置"}]